<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- overview.qdoc -->
  <title>Qt WebSockets Overview | Qt WebSockets 5.15.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 5.15</a></li>
<li><a href="qtwebsockets-index.html">Qt WebSockets</a></li>
<li>Qt WebSockets Overview</li>
<li id="buildversion"><a href="qtwebsockets-index.html">Qt 5.15.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#how-does-it-work">How does it Work?</a></li>
<li class="level1"><a href="#typical-use-cases">Typical Use Cases</a></li>
<li class="level1"><a href="#role-of-qt-websockets">Role of Qt WebSockets</a></li>
<li class="level2"><a href="#qt-websockets-with-cloud-services">Qt WebSockets with Cloud Services</a></li>
<li class="level2"><a href="#related-information">Related Information</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Qt WebSockets Overview</h1>
<span class="subtitle"></span>
<!-- $$$websockets-overview.html-description -->
<div class="descr"> <a name="details"></a>
<p>Qt <a href="nolink">WebSockets</a> enables you to build <a href="nolink">WebSocket</a>-aware applications. It provides an implementation for the <a href="nolink">WebSocket</a> protocol, which is offered by IETF (Internet Engineering Task Force) as a better alternative for bidirectional communication using the existing web infrastructure.</p>
<p>Historically, web applications that needed bidirectional communication or push notifications had to use one of the HTTP-based solutions available. These solutions employed different techniques such as polling, long-polling, and streaming, to overcome the limitations of HTTP protocol, which is not designed for such use cases. This resulted in high network latency, unnecessary data exchange, and stale or old data. The <a href="nolink">WebSocket</a> offering by IETF helps to overcome these problems to a large extent.</p>
<a name="how-does-it-work"></a>
<h2 id="how-does-it-work">How does it Work?</h2>
<p class="centerAlign"><img src="images/websockets-pictorial-representation.jpg" alt="" /></p><p>As you can see in the pictorial representation, <a href="nolink">WebSocket</a>-based solution consists of a client-side and server-side. The native client-side support for <a href="nolink">WebSocket</a> is available on most of the popular web browsers such as Google Chrome, Internet Explorer, Safari, and so on. The server-side support for <a href="nolink">WebSocket</a> makes it a complete solution, enabling bidirectional communication. Any browser with native <a href="nolink">WebSocket</a> support should let you run a simple HTML and JavaScript-based client application using the HTML5 <a href="nolink">WebSocket</a> API.</p>
<p>A <a href="nolink">WebSocket</a> connection begins with a initial HTTP-compatible handshake, which ensures backwards compatibility so that the <a href="nolink">WebSocket</a> connections can share the default HTTP (80) and HTTPS (443) ports. On successful handshake, the connection is open for data exchange, until one of the two entities end the connection.</p>
<p>The <a href="nolink">WebSocket</a> protocol uses <code>ws</code>: and <code>wss</code>: URL schemes to represent unsecure and secure <a href="nolink">WebSocket</a> requests, respectively. During the initial handshake, if a proxy server is detected, the protocol tries to set up a tunnel by issuing an <code>HTTP CONNECT</code> statement to the proxy. The tunnel approach to handle proxies is used irrespective of the request type, although it is proved to work better with TLS (Transport Layer Security) in secure connections.</p>
<a name="typical-use-cases"></a>
<h2 id="typical-use-cases">Typical Use Cases</h2>
<p><a href="nolink">WebSocket</a> suits best for scenarios where,</p>
<ul>
<li>data presented must be up-to-date,</li>
<li>low network latency and minimal data exchange is crucial.</li>
</ul>
<p>A few example applications where we struggle to achieve these using the traditional approach are, instant messaging, online gaming, online stock trading, and so on.</p>
<a name="role-of-qt-websockets"></a>
<h2 id="role-of-qt-websockets">Role of Qt WebSockets</h2>
<p>The Qt <a href="nolink">WebSockets</a> module provides APIs to develop <a href="nolink">WebSocket</a>-based server and client applications. An example of where these APIs can be used is a server application that provides stock data, and a client application that registers for push notification when there is a change in price of a few stocks.</p>
<p>The module provides both C++ and QML versions of the API, so you can choose the alternative that suits your need.</p>
<a name="qt-websockets-with-cloud-services"></a>
<h3 id="qt-websockets-with-cloud-services">Qt WebSockets with Cloud Services</h3>
<p>The client application usually depends on an external service for data. Most of these service providers do not support <a href="nolink">WebSocket</a> yet, so you end up developing a <a href="nolink">WebSocket</a>-aware server application to bridge the gap. You can run the server on an enterprise <a href="nolink">WebSocket</a> gateway service such as a cloud service, avoiding the hassle of maintaining the necessary infrastructure required to host such a service.</p>
<p>Most of the cloud Services provide a Platform as a service (PaaS) backend, which enables deploying and running an instance of your server application on the cloud. The client applications can connect to the running server using a <a href="nolink">WebSocket</a> URL and receive data.</p>
<a name="related-information"></a>
<h3 id="related-information">Related Information</h3>
<ul>
<li><a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a></li>
</ul>
</div>
<!-- @@@websockets-overview.html -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2020 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
