<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qmodbusclient.cpp -->
  <title>QModbusClient Class | Qt Serial Bus 5.15.0</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 5.15</a></li>
<li><a href="qtserialbus-index.html">Qt Serial Bus</a></li>
<li><a href="qtserialbus-module.html">C++ Classes</a></li>
<li>QModbusClient</li>
<li id="buildversion"><a href="qtserialbus-index.html">Qt 5.15.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QModbusClient Class</h1>
<!-- $$$QModbusClient-brief -->
<p>The QModbusClient class is the interface to send Modbus requests. <a href="#details">More...</a></p>
<!-- @@@QModbusClient -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QModbusClient&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += serialbus</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign"> Qt 5.8</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherits:</td><td class="memItemRight bottomAlign"> <a href="qmodbusdevice.html">QModbusDevice</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> Inherited By:</td><td class="memItemRight bottomAlign"> <p><a href="qmodbusrtuserialmaster.html">QModbusRtuSerialMaster</a> and <a href="qmodbustcpclient.html">QModbusTcpClient</a></p>
</td></tr></table></div><p>This class was introduced in Qt 5.8.</p>
<ul>
<li><a href="qmodbusclient-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="properties"></a>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn"><b><a href="qmodbusclient.html#timeout-prop">timeout</a></b> : int</li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#QModbusClient">QModbusClient</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#numberOfRetries">numberOfRetries</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModbusReply *</td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#sendRawRequest">sendRawRequest</a></b>(const QModbusRequest &amp;<i>request</i>, int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModbusReply *</td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#sendReadRequest">sendReadRequest</a></b>(const QModbusDataUnit &amp;<i>read</i>, int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModbusReply *</td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#sendReadWriteRequest">sendReadWriteRequest</a></b>(const QModbusDataUnit &amp;<i>read</i>, const QModbusDataUnit &amp;<i>write</i>, int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QModbusReply *</td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#sendWriteRequest">sendWriteRequest</a></b>(const QModbusDataUnit &amp;<i>write</i>, int <i>serverAddress</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#setNumberOfRetries">setNumberOfRetries</a></b>(int <i>number</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#setTimeout">setTimeout</a></b>(int <i>newTimeout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#timeout-prop">timeout</a></b>() const</td></tr>
</table></div>
<a name="signals"></a>
<h2 id="signals">Signals</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#timeoutChanged">timeoutChanged</a></b>(int <i>newTimeout</i>)</td></tr>
</table></div>
<a name="protected-functions"></a>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#processPrivateResponse">processPrivateResponse</a></b>(const QModbusResponse &amp;<i>response</i>, QModbusDataUnit *<i>data</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qmodbusclient.html#processResponse">processResponse</a></b>(const QModbusResponse &amp;<i>response</i>, QModbusDataUnit *<i>data</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QModbusClient-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>The QModbusClient API is constructed around one QModbusClient object, which holds the common configuration and settings for the requests it sends. One QModbusClient should be enough for the whole Qt application.</p>
<p>Once a QModbusClient object has been created, the application can use it to send requests. The returned object is used to obtain any data returned in response to the corresponding request.</p>
<p>QModbusClient has an asynchronous API. When the finished slot is called, the parameter it takes is the <a href="qmodbusreply.html">QModbusReply</a> object containing the PDU as well as meta-data (Addressing, etc.)&#x2e;</p>
<p>Note: QModbusClient queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. For example, the HTTP protocol on desktop platforms issues 6 requests in parallel for one host/port combination.</p>
</div>
<!-- @@@QModbusClient -->
<div class="prop">
<h2>Property Documentation</h2>
<!-- $$$timeout-prop$$$timeout$$$setTimeoutint$$$timeoutChangedint -->
<h3 class="fn" id="timeout-prop"><a name="timeout-prop"></a><span class="name">timeout</span> : <span class="type">int</span></h3>
<p>This property holds the timeout value used by this client</p>
<p>Returns the timeout value used by this <a href="qmodbusclient.html">QModbusClient</a> instance in ms. A timeout is indicated by a <a href="qmodbusdevice.html#Error-enum">TimeoutError</a>. The default value is 1000 ms.</p>
<p><b>Access functions:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>timeout</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qmodbusclient.html#setTimeout">setTimeout</a></b></span>(int <i>newTimeout</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qmodbusclient.html#timeoutChanged">timeoutChanged</a></b></span>(int <i>newTimeout</i>)</td></tr>
</table></div>
<p><b>See also </b><a href="qmodbusclient.html#setTimeout">setTimeout</a>.</p>
<!-- @@@timeout -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QModbusClient[overload1]$$$QModbusClientQObject* -->
<h3 class="fn" id="QModbusClient"><a name="QModbusClient"></a>QModbusClient::<span class="name">QModbusClient</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>Constructs a Modbus client device with the specified <i>parent</i>.</p>
<!-- @@@QModbusClient -->
<!-- $$$timeoutChanged -->
<h3 class="fn" id="timeoutChanged"><a name="timeoutChanged"></a><code>[signal] </code><span class="type">void</span> QModbusClient::<span class="name">timeoutChanged</span>(<span class="type">int</span> <i>newTimeout</i>)</h3>
<p>This signal is emitted when the timeout used by this <a href="qmodbusclient.html">QModbusClient</a> instance is changed. The new response timeout for the device is passed as <i>newTimeout</i>.</p>
<p><b>Note: </b>Notifier signal for property <a href="qmodbusclient.html#timeout-prop">timeout</a>. </p>
<p><b>See also </b><a href="qmodbusclient.html#setTimeout">setTimeout</a>().</p>
<!-- @@@timeoutChanged -->
<!-- $$$numberOfRetries[overload1]$$$numberOfRetries -->
<h3 class="fn" id="numberOfRetries"><a name="numberOfRetries"></a><span class="type">int</span> QModbusClient::<span class="name">numberOfRetries</span>() const</h3>
<p>Returns the number of retries a client will perform before a request fails. The default value is set to <code>3</code>.</p>
<p><b>See also </b><a href="qmodbusclient.html#setNumberOfRetries">setNumberOfRetries</a>().</p>
<!-- @@@numberOfRetries -->
<!-- $$$processPrivateResponse[overload1]$$$processPrivateResponseconstQModbusResponse&QModbusDataUnit* -->
<h3 class="fn" id="processPrivateResponse"><a name="processPrivateResponse"></a><code>[virtual protected] </code><span class="type">bool</span> QModbusClient::<span class="name">processPrivateResponse</span>(const <span class="type"><a href="qmodbusresponse.html">QModbusResponse</a></span> &amp;<i>response</i>, <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> *<i>data</i>)</h3>
<p>To be implemented by custom Modbus client implementation. The default implementation ignores <i>response</i> and <i>data</i>. It always returns false to indicate error.</p>
<!-- @@@processPrivateResponse -->
<!-- $$$processResponse[overload1]$$$processResponseconstQModbusResponse&QModbusDataUnit* -->
<h3 class="fn" id="processResponse"><a name="processResponse"></a><code>[virtual protected] </code><span class="type">bool</span> QModbusClient::<span class="name">processResponse</span>(const <span class="type"><a href="qmodbusresponse.html">QModbusResponse</a></span> &amp;<i>response</i>, <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> *<i>data</i>)</h3>
<p>Processes a Modbus server <i>response</i> and stores the decoded information in <i>data</i>. Returns true on success; otherwise false.</p>
<!-- @@@processResponse -->
<!-- $$$sendRawRequest[overload1]$$$sendRawRequestconstQModbusRequest&int -->
<h3 class="fn" id="sendRawRequest"><a name="sendRawRequest"></a><span class="type"><a href="qmodbusreply.html">QModbusReply</a></span> *QModbusClient::<span class="name">sendRawRequest</span>(const <span class="type"><a href="qmodbusrequest.html">QModbusRequest</a></span> &amp;<i>request</i>, <span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sends a raw Modbus <i>request</i>. A raw request can contain anything that fits inside the Modbus PDU data section and has a valid function code. The only check performed before sending is therefore the validity check, see <a href="qmodbuspdu.html#isValid">QModbusPdu::isValid</a>. If no error occurred the function returns a a new valid <a href="qmodbusreply.html">QModbusReply</a>; nullptr otherwise. Modbus networks may have multiple servers, each server has a unique <i>serverAddress</i>.</p>
<p><b>See also </b><a href="qmodbusreply.html#rawResult">QModbusReply::rawResult</a>().</p>
<!-- @@@sendRawRequest -->
<!-- $$$sendReadRequest[overload1]$$$sendReadRequestconstQModbusDataUnit&int -->
<h3 class="fn" id="sendReadRequest"><a name="sendReadRequest"></a><span class="type"><a href="qmodbusreply.html">QModbusReply</a></span> *QModbusClient::<span class="name">sendReadRequest</span>(const <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> &amp;<i>read</i>, <span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sends a request to read the contents of the data pointed by <i>read</i>. Returns a new valid <a href="qmodbusreply.html">QModbusReply</a> object if no error occurred, otherwise nullptr. Modbus network may have multiple servers, each server has unique <i>serverAddress</i>.</p>
<!-- @@@sendReadRequest -->
<!-- $$$sendReadWriteRequest[overload1]$$$sendReadWriteRequestconstQModbusDataUnit&constQModbusDataUnit&int -->
<h3 class="fn" id="sendReadWriteRequest"><a name="sendReadWriteRequest"></a><span class="type"><a href="qmodbusreply.html">QModbusReply</a></span> *QModbusClient::<span class="name">sendReadWriteRequest</span>(const <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> &amp;<i>read</i>, const <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> &amp;<i>write</i>, <span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sends a request to read the contents of the data pointed by <i>read</i> and to modify the contents of the data pointed by <i>write</i> using Modbus function code <a href="qmodbuspdu.html#FunctionCode-enum">QModbusPdu::ReadWriteMultipleRegisters</a>. Returns a new valid <a href="qmodbusreply.html">QModbusReply</a> object if no error occurred, otherwise nullptr. Modbus network may have multiple servers, each server has unique <i>serverAddress</i>.</p>
<p><b>Note: </b>: Sending this kind of request is only valid of both <i>read</i> and <i>write</i> are of type <a href="qmodbusdataunit.html#RegisterType-enum">QModbusDataUnit::HoldingRegisters</a>.</p>
<!-- @@@sendReadWriteRequest -->
<!-- $$$sendWriteRequest[overload1]$$$sendWriteRequestconstQModbusDataUnit&int -->
<h3 class="fn" id="sendWriteRequest"><a name="sendWriteRequest"></a><span class="type"><a href="qmodbusreply.html">QModbusReply</a></span> *QModbusClient::<span class="name">sendWriteRequest</span>(const <span class="type"><a href="qmodbusdataunit.html">QModbusDataUnit</a></span> &amp;<i>write</i>, <span class="type">int</span> <i>serverAddress</i>)</h3>
<p>Sends a request to modify the contents of the data pointed by <i>write</i>. Returns a new valid <a href="qmodbusreply.html">QModbusReply</a> object if no error occurred, otherwise nullptr. Modbus network may have multiple servers, each server has unique <i>serverAddress</i>.</p>
<!-- @@@sendWriteRequest -->
<!-- $$$setNumberOfRetries[overload1]$$$setNumberOfRetriesint -->
<h3 class="fn" id="setNumberOfRetries"><a name="setNumberOfRetries"></a><span class="type">void</span> QModbusClient::<span class="name">setNumberOfRetries</span>(<span class="type">int</span> <i>number</i>)</h3>
<p>Sets the <i>number</i> of retries a client will perform before a request fails. The default value is set to <code>3</code>.</p>
<p><b>Note: </b>The new value must be greater than or equal to <code>0</code>. Changing this property will only effect new requests, not already scheduled ones.</p>
<p><b>See also </b><a href="qmodbusclient.html#numberOfRetries">numberOfRetries</a>().</p>
<!-- @@@setNumberOfRetries -->
<!-- $$$setTimeout -->
<h3 class="fn" id="setTimeout"><a name="setTimeout"></a><span class="type">void</span> QModbusClient::<span class="name">setTimeout</span>(<span class="type">int</span> <i>newTimeout</i>)</h3>
<p>Sets the <i>newTimeout</i> for this <a href="qmodbusclient.html">QModbusClient</a> instance. The minimum timeout is 10 ms.</p>
<p>The timeout is used by the client to determine how long it waits for a response from the server. If the response is not received within the required timeout, the <a href="qmodbusdevice.html#Error-enum">TimeoutError</a> is set.</p>
<p>Already active/running timeouts are not affected by such timeout duration changes.</p>
<p><b>Note: </b>Setter function for property <a href="qmodbusclient.html#timeout-prop">timeout</a>. </p>
<p><b>See also </b><a href="qmodbusclient.html#timeout-prop">timeout</a> and <a href="qmodbusclient.html#timeoutChanged">timeoutChanged</a>().</p>
<!-- @@@setTimeout -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2020 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
