<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<!-- qgl.cpp -->
  <title>QGLContext Class | Qt OpenGL</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
    <div class="main">
    <div class="main-rounded">
        <div class="navigationbar">
        <ul>
<li><a href="../qtdoc/index.html">Qt 5.15</a></li>
<li><a href="qtopengl-index.html">Qt OpenGL</a></li>
<li><a href="qtopengl-module.html">C++ Classes</a></li>
<li>QGLContext</li>
<li id="buildversion"><a href="qtopengl-index.html">Qt 5.15.0 Reference Documentation</a></li>
    </ul>
    </div>
</div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QGLContext Class</h1>
<!-- $$$QGLContext-brief -->
<p>The QGLContext class encapsulates an OpenGL rendering context. <a href="#details">More...</a></p>
<!-- @@@QGLContext -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Header:</td><td class="memItemRight bottomAlign">  <span class="preprocessor">#include &lt;QGLContext&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += opengl</td></tr></table></div><p><b>This class is obsolete.</b> It is provided to keep old source code working. We strongly advise against using it in new code.</p>
<ul>
<li><a href="qglcontext-members.html">List of all members, including inherited members</a></li>
<li><a href="qglcontext-obsolete.html">Obsolete members</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#BindOption-enum">BindOption</a></b> { NoBindOption, InvertedYBindOption, MipmapBindOption, PremultipliedAlphaBindOption, LinearFilteringBindOption, DefaultBindOption }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#BindOption-enum">BindOptions</a></b></td></tr>
</table></div>
<a name="public-functions"></a>
<h2 id="public-functions">Public Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#QGLContext-1">QGLContext</a></b>(const QGLFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#dtor.QGLContext">~QGLContext</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture">bindTexture</a></b>(const QImage &amp;<i>image</i>, GLenum <i>target</i>, GLint <i>format</i>, QGLContext::BindOptions <i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture-1">bindTexture</a></b>(const QPixmap &amp;<i>pixmap</i>, GLenum <i>target</i>, GLint <i>format</i>, QGLContext::BindOptions <i>options</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture-2">bindTexture</a></b>(const QImage &amp;<i>image</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLint <i>format</i> = GL_RGBA)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture-3">bindTexture</a></b>(const QPixmap &amp;<i>pixmap</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLint <i>format</i> = GL_RGBA)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture-4">bindTexture</a></b>(const QString &amp;<i>fileName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QOpenGLContext *</td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#contextHandle">contextHandle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#create">create</a></b>(const QGLContext *<i>shareContext</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#deleteTexture">deleteTexture</a></b>(GLuint <i>id</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPaintDevice *</td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#device">device</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#doneCurrent">doneCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#drawTexture">drawTexture</a></b>(const QRectF &amp;<i>target</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#drawTexture-1">drawTexture</a></b>(const QPointF &amp;<i>point</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFormat </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#format">format</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFunctions *</td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#functions">functions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFunctionPointer </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#getProcAddress">getProcAddress</a></b>(const QString &amp;<i>proc</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#isSharing">isSharing</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#isValid">isValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#makeCurrent">makeCurrent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#moveToThread">moveToThread</a></b>(QThread *<i>thread</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QColor </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#overlayTransparentColor">overlayTransparentColor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFormat </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#requestedFormat">requestedFormat</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#reset">reset</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#setFormat">setFormat</a></b>(const QGLFormat &amp;<i>format</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#swapBuffers">swapBuffers</a></b>() const</td></tr>
</table></div>
<a name="static-public-members"></a>
<h2 id="static-public-members">Static Public Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#areSharing">areSharing</a></b>(const QGLContext *<i>context1</i>, const QGLContext *<i>context2</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QGLContext *</td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#currentContext">currentContext</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLContext *</td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#fromOpenGLContext">fromOpenGLContext</a></b>(QOpenGLContext *<i>context</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#setTextureCacheLimit">setTextureCacheLimit</a></b>(int <i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#textureCacheLimit">textureCacheLimit</a></b>()</td></tr>
</table></div>
<a name="protected-functions"></a>
<h2 id="protected-functions">Protected Functions</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#chooseContext">chooseContext</a></b>(const QGLContext *<i>shareContext</i> = 0)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#deviceIsPixmap">deviceIsPixmap</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#initialized">initialized</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#setInitialized">setInitialized</a></b>(bool <i>on</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#setWindowCreated">setWindowCreated</a></b>(bool <i>on</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#windowCreated">windowCreated</a></b>() const</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QGLContext-description -->
<div class="descr">
<h2 id="details">Detailed Description</h2>
<p>An OpenGL rendering context is a complete set of OpenGL state variables. The rendering context's <a href="qgl.html#FormatOption-enum">format</a> is set in the constructor, but it can also be set later with <a href="qglcontext.html#setFormat">setFormat</a>(). The format options that are actually set are returned by <a href="qglcontext.html#format">format</a>(); the options you asked for are returned by <a href="qglcontext.html#requestedFormat">requestedFormat</a>(). Note that after a QGLContext object has been constructed, the actual OpenGL context must be created by explicitly calling the <a href="qglcontext.html#create">create</a>() function. The <a href="qglcontext.html#makeCurrent">makeCurrent</a>() function makes this context the current rendering context. You can make <i>no</i> context current using <a href="qglcontext.html#doneCurrent">doneCurrent</a>(). The <a href="qglcontext.html#reset">reset</a>() function will reset the context and make it invalid.</p>
<p>You can examine properties of the context with, e.g&#x2e; <a href="qglcontext.html#isValid">isValid</a>(), <a href="qglcontext.html#isSharing">isSharing</a>(), <a href="qglcontext.html#initialized">initialized</a>(), <a href="qglcontext.html#windowCreated">windowCreated</a>() and <a href="qglcontext.html#overlayTransparentColor">overlayTransparentColor</a>().</p>
<p>If you're using double buffering you can swap the screen contents with the off-screen buffer using <a href="qglcontext.html#swapBuffers">swapBuffers</a>().</p>
<p>Please note that QGLContext is not thread safe.</p>
</div>
<!-- @@@QGLContext -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$BindOption$$$NoBindOption$$$InvertedYBindOption$$$MipmapBindOption$$$PremultipliedAlphaBindOption$$$LinearFilteringBindOption$$$MemoryManagedBindOption$$$CanFlipNativePixmapBindOption$$$TemporarilyCachedBindOption$$$DefaultBindOption$$$InternalBindOption -->
<h3 class="flags" id="BindOption-enum"><a name="BindOption-enum"></a>enum QGLContext::<span class="name">BindOption</span><br/>flags QGLContext::<span class="name">BindOptions</span></h3>
<p>A set of options to decide how to bind a texture using <a href="qglcontext.html#bindTexture">bindTexture</a>().</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td class="topAlign"><code>QGLContext::NoBindOption</code></td><td class="topAlign tblval"><code>0x0000</code></td><td class="topAlign">Don't do anything, pass the texture straight through.</td></tr>
<tr><td class="topAlign"><code>QGLContext::InvertedYBindOption</code></td><td class="topAlign tblval"><code>0x0001</code></td><td class="topAlign">Specifies that the texture should be flipped over the X axis so that the texture coordinate 0,0 corresponds to the top left corner. Inverting the texture implies a deep copy prior to upload.</td></tr>
<tr><td class="topAlign"><code>QGLContext::MipmapBindOption</code></td><td class="topAlign tblval"><code>0x0002</code></td><td class="topAlign">Specifies that <a href="qglcontext.html#bindTexture">bindTexture</a>() should try to generate mipmaps. If the GL implementation supports the <code>GL_SGIS_generate_mipmap</code> extension, mipmaps will be automatically generated for the texture. Mipmap generation is only supported for the <code>GL_TEXTURE_2D</code> target.</td></tr>
<tr><td class="topAlign"><code>QGLContext::PremultipliedAlphaBindOption</code></td><td class="topAlign tblval"><code>0x0004</code></td><td class="topAlign">Specifies that the image should be uploaded with premultiplied alpha and does a conversion accordingly.</td></tr>
<tr><td class="topAlign"><code>QGLContext::LinearFilteringBindOption</code></td><td class="topAlign tblval"><code>0x0008</code></td><td class="topAlign">Specifies that the texture filtering should be set to GL_LINEAR. Default is GL_NEAREST. If mipmap is also enabled, filtering will be set to GL_LINEAR_MIPMAP_LINEAR.</td></tr>
<tr><td class="topAlign"><code>QGLContext::DefaultBindOption</code></td><td class="topAlign tblval"><code>LinearFilteringBindOption
                                                  | InvertedYBindOption
                                                  | MipmapBindOption</code></td><td class="topAlign">In Qt 4.5 and earlier, <a href="qglcontext.html#bindTexture">bindTexture</a>() would mirror the image and automatically generate mipmaps. This option helps preserve this default behavior.</td></tr>
</table></div>
<p>This enum was introduced or modified in Qt 4.6.</p>
<p>The BindOptions type is a typedef for <a href="../qtcore/qflags.html">QFlags</a>&lt;BindOption&gt;. It stores an OR combination of BindOption values.</p>
<!-- @@@BindOption -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QGLContext$$$QGLContextconstQGLFormat& -->
<h3 class="fn" id="QGLContext-1"><a name="QGLContext-1"></a>QGLContext::<span class="name">QGLContext</span>(const <span class="type"><a href="qglformat.html">QGLFormat</a></span> &amp;<i>format</i>)</h3>
<p>Constructs an OpenGL context with the given <i>format</i> which specifies several display options for the context.</p>
<p>If the underlying OpenGL/Window system cannot satisfy all the features requested in <i>format</i>, the nearest subset of features will be used. After creation, the <a href="qglcontext.html#format">format</a>() method will return the actual format obtained.</p>
<p>Note that after a QGLContext object has been constructed, <a href="qglcontext.html#create">create</a>() must be called explicitly to create the actual OpenGL context. The context will be <a href="qglcontext.html#isValid">invalid</a> if it was not possible to obtain a GL context at all.</p>
<p><b>See also </b><a href="qglcontext.html#format">format</a>() and <a href="qglcontext.html#isValid">isValid</a>().</p>
<!-- @@@QGLContext -->
<!-- $$$~QGLContext[overload1]$$$~QGLContext -->
<h3 class="fn" id="dtor.QGLContext"><a name="dtor.QGLContext"></a><code>[virtual] </code>QGLContext::<span class="name">~QGLContext</span>()</h3>
<p>Destroys the OpenGL context and frees its resources.</p>
<!-- @@@~QGLContext -->
<!-- $$$areSharing[overload1]$$$areSharingconstQGLContext*constQGLContext* -->
<h3 class="fn" id="areSharing"><a name="areSharing"></a><code>[static] </code><span class="type">bool</span> QGLContext::<span class="name">areSharing</span>(const <span class="type"><a href="qglcontext-obsolete.html#QGLContext">QGLContext</a></span> *<i>context1</i>, const <span class="type"><a href="qglcontext-obsolete.html#QGLContext">QGLContext</a></span> *<i>context2</i>)</h3>
<p>Returns <code>true</code> if <i>context1</i> and <i>context2</i> are sharing their GL resources such as textures, shader programs, etc; otherwise returns <code>false</code>.</p>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@areSharing -->
<!-- $$$bindTexture[overload1]$$$bindTextureconstQImage&GLenumGLintQGLContext::BindOptions -->
<h3 class="fn" id="bindTexture"><a name="bindTexture"></a><span class="type">GLuint</span> QGLContext::<span class="name">bindTexture</span>(const <span class="type"><a href="../qtgui/qimage.html">QImage</a></span> &amp;<i>image</i>, <span class="type">GLenum</span> <i>target</i>, <span class="type">GLint</span> <i>format</i>, <span class="type"><a href="qglcontext.html#BindOption-enum">QGLContext::BindOptions</a></span> <i>options</i>)</h3>
<p>Generates and binds a 2D GL texture to the current context, based on <i>image</i>. The generated texture id is returned and can be used in later <code>glBindTexture()</code> calls.</p>
<p>The <i>target</i> parameter specifies the texture target. The default target is <code>GL_TEXTURE_2D</code>.</p>
<p>The <i>format</i> parameter sets the internal format for the texture. The default format is <code>GL_RGBA</code>.</p>
<p>The binding <i>options</i> are a set of options used to decide how to bind the texture to the context.</p>
<p>The texture that is generated is cached, so multiple calls to bindTexture() with the same <a href="../qtgui/qimage.html">QImage</a> will return the same texture id.</p>
<p>Note that we assume default values for the glPixelStore() and glPixelTransfer() parameters.</p>
<p>This function was introduced in Qt 4.6.</p>
<p><b>See also </b><a href="qglcontext.html#deleteTexture">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQPixmap&GLenumGLintQGLContext::BindOptions -->
<h3 class="fn" id="bindTexture-1"><a name="bindTexture-1"></a><span class="type">GLuint</span> QGLContext::<span class="name">bindTexture</span>(const <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> &amp;<i>pixmap</i>, <span class="type">GLenum</span> <i>target</i>, <span class="type">GLint</span> <i>format</i>, <span class="type"><a href="qglcontext.html#BindOption-enum">QGLContext::BindOptions</a></span> <i>options</i>)</h3>
<p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture to the current context, based on <i>pixmap</i>.</p>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQImage&GLenumGLint -->
<h3 class="fn" id="bindTexture-2"><a name="bindTexture-2"></a><span class="type">GLuint</span> QGLContext::<span class="name">bindTexture</span>(const <span class="type"><a href="../qtgui/qimage.html">QImage</a></span> &amp;<i>image</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D, <span class="type">GLint</span> <i>format</i> = GL_RGBA)</h3>
<p>Generates and binds a 2D GL texture to the current context, based on <i>image</i>. The generated texture id is returned and can be used in later <code>glBindTexture()</code> calls.</p>
<p>This is an overloaded function.</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQPixmap&GLenumGLint -->
<h3 class="fn" id="bindTexture-3"><a name="bindTexture-3"></a><span class="type">GLuint</span> QGLContext::<span class="name">bindTexture</span>(const <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> &amp;<i>pixmap</i>, <span class="type">GLenum</span> <i>target</i> = GL_TEXTURE_2D, <span class="type">GLint</span> <i>format</i> = GL_RGBA)</h3>
<p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture based on <i>pixmap</i>.</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQString& -->
<h3 class="fn" id="bindTexture-4"><a name="bindTexture-4"></a><span class="type">GLuint</span> QGLContext::<span class="name">bindTexture</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>fileName</i>)</h3>
<p>This is an overloaded function.</p>
<p>Reads the compressed texture file <i>fileName</i> and generates a 2D GL texture from it.</p>
<p>This function can load DirectDrawSurface (DDS) textures in the DXT1, DXT3 and DXT5 DDS formats if the <code>GL_ARB_texture_compression</code> and <code>GL_EXT_texture_compression_s3tc</code> extensions are supported.</p>
<p>Since 4.6&#x2e;1, textures in the ETC1 format can be loaded if the <code>GL_OES_compressed_ETC1_RGB8_texture</code> extension is supported and the ETC1 texture has been encapsulated in the PVR container format. Also, textures in the PVRTC2 and PVRTC4 formats can be loaded if the <code>GL_IMG_texture_compression_pvrtc</code> extension is supported.</p>
<p><b>See also </b><a href="qglcontext.html#deleteTexture">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$chooseContext[overload1]$$$chooseContextconstQGLContext* -->
<h3 class="fn" id="chooseContext"><a name="chooseContext"></a><code>[virtual protected] </code><span class="type">bool</span> QGLContext::<span class="name">chooseContext</span>(const <span class="type"><a href="qglcontext-obsolete.html#QGLContext">QGLContext</a></span> *<i>shareContext</i> = 0)</h3>
<p>This semi-internal function is called by <a href="qglcontext.html#create">create</a>(). It creates a system-dependent OpenGL handle that matches the <a href="qglcontext.html#format">format</a>() of <i>shareContext</i> as closely as possible, returning true if successful or false if a suitable handle could not be found.</p>
<p>On Windows, it calls the virtual function choosePixelFormat(), which finds a matching pixel format identifier. On X11, it calls the virtual function chooseVisual() which finds an appropriate X visual. On other platforms it may work differently.</p>
<!-- @@@chooseContext -->
<!-- $$$contextHandle[overload1]$$$contextHandle -->
<h3 class="fn" id="contextHandle"><a name="contextHandle"></a><span class="type"><a href="../qtgui/qopenglcontext.html">QOpenGLContext</a></span> *QGLContext::<span class="name">contextHandle</span>() const</h3>
<p>Returns the OpenGL context handle.</p>
<!-- @@@contextHandle -->
<!-- $$$create[overload1]$$$createconstQGLContext* -->
<h3 class="fn" id="create"><a name="create"></a><code>[virtual] </code><span class="type">bool</span> QGLContext::<span class="name">create</span>(const <span class="type"><a href="qglcontext-obsolete.html#QGLContext">QGLContext</a></span> *<i>shareContext</i> = nullptr)</h3>
<p>Creates the GL context. Returns <code>true</code> if it was successful in creating a valid GL rendering context on the paint device specified in the constructor; otherwise returns <code>false</code> (i.e&#x2e; the context is invalid).</p>
<p>If the OpenGL implementation on your system does not support the requested version of OpenGL context, then <a href="qglcontext.html" class="obsolete">QGLContext</a> will try to create the closest matching version. The actual created context properties can be queried using the QGLFormat returned by the <a href="qglcontext.html#format">format</a>() function. For example, if you request a context that supports OpenGL 4.3 Core profile but the driver and/or hardware only supports version 3.2 Core profile contexts then you will get a 3.2 Core profile context.</p>
<p>After successful creation, <a href="qglcontext.html#format">format</a>() returns the set of features of the created GL rendering context.</p>
<p>If <i>shareContext</i> points to a valid <a href="qglcontext.html" class="obsolete">QGLContext</a>, this method will try to establish OpenGL display list and texture object sharing between this context and the <i>shareContext</i>. Note that this may fail if the two contexts have different <a href="qglcontext.html#format">formats</a>. Use <a href="qglcontext.html#isSharing">isSharing</a>() to see if sharing is in effect.</p>
<p><b>Warning:</b> Implementation note: initialization of C++ class members usually takes place in the class constructor. <a href="qglcontext.html" class="obsolete">QGLContext</a> is an exception because it must be simple to customize. The virtual functions <a href="qglcontext.html#chooseContext">chooseContext</a>() (and chooseVisual() for X11) can be reimplemented in a subclass to select a particular context. The problem is that virtual functions are not properly called during construction (even though this is correct C++) because C++ constructs class hierarchies from the bottom up. For this reason we need a create() function.</p>
<p><b>See also </b><a href="qglcontext.html#chooseContext">chooseContext</a>(), <a href="qglcontext.html#format">format</a>(), and <a href="qglcontext.html#isValid">isValid</a>().</p>
<!-- @@@create -->
<!-- $$$currentContext[overload1]$$$currentContext -->
<h3 class="fn" id="currentContext"><a name="currentContext"></a><code>[static] </code>const <span class="type"><a href="qglcontext-obsolete.html#QGLContext">QGLContext</a></span> *QGLContext::<span class="name">currentContext</span>()</h3>
<p>Returns the current context, i.e&#x2e; the context to which any OpenGL commands will currently be directed. Returns 0 if no context is current.</p>
<p><b>See also </b><a href="qglcontext.html#makeCurrent">makeCurrent</a>().</p>
<!-- @@@currentContext -->
<!-- $$$deleteTexture[overload1]$$$deleteTextureGLuint -->
<h3 class="fn" id="deleteTexture"><a name="deleteTexture"></a><span class="type">void</span> QGLContext::<span class="name">deleteTexture</span>(<span class="type">GLuint</span> <i>id</i>)</h3>
<p>Removes the texture identified by <i>id</i> from the texture cache, and calls glDeleteTextures() to delete the texture from the context.</p>
<p><b>See also </b><a href="qglcontext.html#bindTexture">bindTexture</a>().</p>
<!-- @@@deleteTexture -->
<!-- $$$device[overload1]$$$device -->
<h3 class="fn" id="device"><a name="device"></a><span class="type"><a href="../qtgui/qpaintdevice.html">QPaintDevice</a></span> *QGLContext::<span class="name">device</span>() const</h3>
<p>Returns the paint device set for this context.</p>
<p><b>See also </b><a href="qglcontext-obsolete.html#QGLContext">QGLContext::QGLContext</a>().</p>
<!-- @@@device -->
<!-- $$$deviceIsPixmap[overload1]$$$deviceIsPixmap -->
<h3 class="fn" id="deviceIsPixmap"><a name="deviceIsPixmap"></a><code>[protected] </code><span class="type">bool</span> QGLContext::<span class="name">deviceIsPixmap</span>() const</h3>
<p>Returns <code>true</code> if the paint device of this context is a pixmap; otherwise returns <code>false</code>.</p>
<p>Since Qt 5 the paint device is never actually a pixmap. renderPixmap() is however still simulated using framebuffer objects and readbacks, and this function will return <code>true</code> in this case.</p>
<!-- @@@deviceIsPixmap -->
<!-- $$$doneCurrent[overload1]$$$doneCurrent -->
<h3 class="fn" id="doneCurrent"><a name="doneCurrent"></a><code>[virtual] </code><span class="type">void</span> QGLContext::<span class="name">doneCurrent</span>()</h3>
<p>Makes no GL context the current context. Normally, you do not need to call this function; <a href="qglcontext.html" class="obsolete">QGLContext</a> calls it as necessary.</p>
<!-- @@@doneCurrent -->
<!-- $$$drawTexture[overload1]$$$drawTextureconstQRectF&GLuintGLenum -->
<h3 class="fn" id="drawTexture"><a name="drawTexture"></a><span class="type">void</span> QGLContext::<span class="name">drawTexture</span>(const <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> &amp;<i>target</i>, <span class="type">GLuint</span> <i>textureId</i>, <span class="type">GLenum</span> <i>textureTarget</i> = GL_TEXTURE_2D)</h3>
<p>This function supports the following use cases:</p>
<ul>
<li>On OpenGL and OpenGL ES 1.x it draws the given texture, <i>textureId</i>, to the given target rectangle, <i>target</i>, in OpenGL model space. The <i>textureTarget</i> should be a 2D texture target.</li>
<li>On OpenGL and OpenGL ES 2.x, if a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type <a href="../qtgui/qpaintengine.html#Type-enum">QPaintEngine::OpenGL2</a>, the function will draw the given texture, <i>textureId</i>, to the given target rectangle, <i>target</i>, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case, and that this is the only supported use case under OpenGL ES 2.x&#x2e;</li>
</ul>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$drawTexture$$$drawTextureconstQPointF&GLuintGLenum -->
<h3 class="fn" id="drawTexture-1"><a name="drawTexture-1"></a><span class="type">void</span> QGLContext::<span class="name">drawTexture</span>(const <span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> &amp;<i>point</i>, <span class="type">GLuint</span> <i>textureId</i>, <span class="type">GLenum</span> <i>textureTarget</i> = GL_TEXTURE_2D)</h3>
<p>This function supports the following use cases:</p>
<ul>
<li>By default it draws the given texture, <i>textureId</i>, at the given <i>point</i> in OpenGL model space. The <i>textureTarget</i> should be a 2D texture target.</li>
<li>If a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type <a href="../qtgui/qpaintengine.html#Type-enum">QPaintEngine::OpenGL2</a>, the function will draw the given texture, <i>textureId</i>, at the given <i>point</i>, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case.</li>
</ul>
<p><b>Note: </b>This function is not supported under any version of OpenGL ES.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn" id="format"><a name="format"></a><span class="type"><a href="qglformat.html">QGLFormat</a></span> QGLContext::<span class="name">format</span>() const</h3>
<p>Returns the frame buffer format that was obtained (this may be a subset of what was requested).</p>
<p><b>See also </b><a href="qglcontext.html#setFormat">setFormat</a>() and <a href="qglcontext.html#requestedFormat">requestedFormat</a>().</p>
<!-- @@@format -->
<!-- $$$fromOpenGLContext[overload1]$$$fromOpenGLContextQOpenGLContext* -->
<h3 class="fn" id="fromOpenGLContext"><a name="fromOpenGLContext"></a><code>[static] </code><span class="type"><a href="qglcontext-obsolete.html#QGLContext">QGLContext</a></span> *QGLContext::<span class="name">fromOpenGLContext</span>(<span class="type"><a href="../qtgui/qopenglcontext.html">QOpenGLContext</a></span> *<i>context</i>)</h3>
<p>Returns an OpenGL context for the window context specified by the <i>context</i> parameter.</p>
<!-- @@@fromOpenGLContext -->
<!-- $$$functions[overload1]$$$functions -->
<h3 class="fn" id="functions"><a name="functions"></a><span class="type"><a href="qglfunctions.html">QGLFunctions</a></span> *QGLContext::<span class="name">functions</span>() const</h3>
<p>Returns a QGLFunctions object that is initialized for this context.</p>
<!-- @@@functions -->
<!-- $$$getProcAddress[overload1]$$$getProcAddressconstQString& -->
<h3 class="fn" id="getProcAddress"><a name="getProcAddress"></a><span class="type"><a href="../qtcore/qtglobal.html#QFunctionPointer-typedef">QFunctionPointer</a></span> QGLContext::<span class="name">getProcAddress</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>proc</i>) const</h3>
<p>Returns a function pointer to the GL extension function passed in <i>proc</i>. <code>nullptr</code> is returned if a pointer to the function could not be obtained.</p>
<!-- @@@getProcAddress -->
<!-- $$$initialized[overload1]$$$initialized -->
<h3 class="fn" id="initialized"><a name="initialized"></a><code>[protected] </code><span class="type">bool</span> QGLContext::<span class="name">initialized</span>() const</h3>
<p>Returns <code>true</code> if this context has been initialized, i.e&#x2e; if <a href="qglwidget.html#initializeGL">QGLWidget::initializeGL</a>() has been performed on it; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qglcontext.html#setInitialized">setInitialized</a>().</p>
<!-- @@@initialized -->
<!-- $$$isSharing[overload1]$$$isSharing -->
<h3 class="fn" id="isSharing"><a name="isSharing"></a><span class="type">bool</span> QGLContext::<span class="name">isSharing</span>() const</h3>
<p>Returns <code>true</code> if this context is sharing its GL context with another <a href="qglcontext.html" class="obsolete">QGLContext</a>, otherwise false is returned. Note that context sharing might not be supported between contexts with different formats.</p>
<!-- @@@isSharing -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn" id="isValid"><a name="isValid"></a><span class="type">bool</span> QGLContext::<span class="name">isValid</span>() const</h3>
<p>Returns <code>true</code> if a GL rendering context has been successfully created; otherwise returns <code>false</code>.</p>
<!-- @@@isValid -->
<!-- $$$makeCurrent[overload1]$$$makeCurrent -->
<h3 class="fn" id="makeCurrent"><a name="makeCurrent"></a><code>[virtual] </code><span class="type">void</span> QGLContext::<span class="name">makeCurrent</span>()</h3>
<p>Makes this context the current OpenGL rendering context. All GL functions you call operate on this context until another context is made current.</p>
<p>In some very rare cases the underlying call may fail. If this occurs an error message is output to stderr.</p>
<p>If you call this from a thread other than the main UI thread, make sure you've first pushed the context to the relevant thread from the UI thread using <a href="qglcontext.html#moveToThread">moveToThread</a>().</p>
<!-- @@@makeCurrent -->
<!-- $$$moveToThread[overload1]$$$moveToThreadQThread* -->
<h3 class="fn" id="moveToThread"><a name="moveToThread"></a><span class="type">void</span> QGLContext::<span class="name">moveToThread</span>(<span class="type"><a href="../qtcore/qthread.html">QThread</a></span> *<i>thread</i>)</h3>
<p>Moves the <a href="qglcontext.html" class="obsolete">QGLContext</a> to the given <i>thread</i>.</p>
<p>Enables calling <a href="qglcontext.html#swapBuffers">swapBuffers</a>() and <a href="qglcontext.html#makeCurrent">makeCurrent</a>() on the context in the given thread.</p>
<!-- @@@moveToThread -->
<!-- $$$overlayTransparentColor[overload1]$$$overlayTransparentColor -->
<h3 class="fn" id="overlayTransparentColor"><a name="overlayTransparentColor"></a><span class="type"><a href="../qtgui/qcolor.html">QColor</a></span> QGLContext::<span class="name">overlayTransparentColor</span>() const</h3>
<p>If this context is a valid context in an overlay plane, returns the plane's transparent color. Otherwise returns an <a href="../qtgui/qcolor.html#isValid">invalid</a> color.</p>
<p>The returned color's <a href="../qtwidgets/qcolormap.html#pixel">pixel</a> value is the index of the transparent color in the colormap of the overlay plane. (Naturally, the color's RGB values are meaningless.)</p>
<p>The returned <a href="../qtgui/qcolor.html">QColor</a> object will generally work as expected only when passed as the argument to <a href="qglwidget.html#qglColor">QGLWidget::qglColor</a>() or <a href="qglwidget.html#qglClearColor">QGLWidget::qglClearColor</a>(). Under certain circumstances it can also be used to draw transparent graphics with a <a href="../qtgui/qpainter.html">QPainter</a>.</p>
<!-- @@@overlayTransparentColor -->
<!-- $$$requestedFormat[overload1]$$$requestedFormat -->
<h3 class="fn" id="requestedFormat"><a name="requestedFormat"></a><span class="type"><a href="qglformat.html">QGLFormat</a></span> QGLContext::<span class="name">requestedFormat</span>() const</h3>
<p>Returns the frame buffer format that was originally requested in the constructor or <a href="qglcontext.html#setFormat">setFormat</a>().</p>
<p><b>See also </b><a href="qglcontext.html#format">format</a>().</p>
<!-- @@@requestedFormat -->
<!-- $$$reset[overload1]$$$reset -->
<h3 class="fn" id="reset"><a name="reset"></a><span class="type">void</span> QGLContext::<span class="name">reset</span>()</h3>
<p>Resets the context and makes it invalid.</p>
<p><b>See also </b><a href="qglcontext.html#create">create</a>() and <a href="qglcontext.html#isValid">isValid</a>().</p>
<!-- @@@reset -->
<!-- $$$setFormat[overload1]$$$setFormatconstQGLFormat& -->
<h3 class="fn" id="setFormat"><a name="setFormat"></a><span class="type">void</span> QGLContext::<span class="name">setFormat</span>(const <span class="type"><a href="qglformat.html">QGLFormat</a></span> &amp;<i>format</i>)</h3>
<p>Sets a <i>format</i> for this context. The context is <a href="qglcontext.html#reset">reset</a>.</p>
<p>Call <a href="qglcontext.html#create">create</a>() to create a new GL context that tries to match the new format.</p>
<pre class="cpp">
 <span class="type"><a href="qglcontext-obsolete.html#QGLContext">QGLContext</a></span> <span class="operator">*</span>cx;
 <span class="comment">//  ...</span>
 <span class="type"><a href="qglformat.html">QGLFormat</a></span> f;
 f<span class="operator">.</span>setStereo(<span class="keyword">true</span>);
 cx<span class="operator">-</span><span class="operator">&gt;</span>setFormat(f);
 <span class="keyword">if</span> (<span class="operator">!</span>cx<span class="operator">-</span><span class="operator">&gt;</span>create())
     exit(); <span class="comment">// no OpenGL support, or cannot render on the specified paintdevice</span>
 <span class="keyword">if</span> (<span class="operator">!</span>cx<span class="operator">-</span><span class="operator">&gt;</span>format()<span class="operator">.</span>stereo())
     exit(); <span class="comment">// could not create stereo context</span>
</pre>
<p><b>See also </b><a href="qglcontext.html#format">format</a>(), <a href="qglcontext.html#reset">reset</a>(), and <a href="qglcontext.html#create">create</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setInitialized[overload1]$$$setInitializedbool -->
<h3 class="fn" id="setInitialized"><a name="setInitialized"></a><code>[protected] </code><span class="type">void</span> QGLContext::<span class="name">setInitialized</span>(<span class="type">bool</span> <i>on</i>)</h3>
<p>If <i>on</i> is true the context has been initialized, i.e&#x2e; QGLContext::setInitialized() has been called on it. If <i>on</i> is false the context has not been initialized.</p>
<p><b>See also </b><a href="qglcontext.html#initialized">initialized</a>().</p>
<!-- @@@setInitialized -->
<!-- $$$setTextureCacheLimit[overload1]$$$setTextureCacheLimitint -->
<h3 class="fn" id="setTextureCacheLimit"><a name="setTextureCacheLimit"></a><code>[static] </code><span class="type">void</span> QGLContext::<span class="name">setTextureCacheLimit</span>(<span class="type">int</span> <i>size</i>)</h3>
<p>This function sets the limit for the texture cache to <i>size</i>, expressed in kilobytes.</p>
<p>By default, the cache limit is approximately 64 MB.</p>
<p><b>See also </b><a href="qglcontext.html#textureCacheLimit">textureCacheLimit</a>().</p>
<!-- @@@setTextureCacheLimit -->
<!-- $$$setWindowCreated[overload1]$$$setWindowCreatedbool -->
<h3 class="fn" id="setWindowCreated"><a name="setWindowCreated"></a><code>[protected] </code><span class="type">void</span> QGLContext::<span class="name">setWindowCreated</span>(<span class="type">bool</span> <i>on</i>)</h3>
<p>If <i>on</i> is true the context has had a window created for it. If <i>on</i> is false no window has been created for the context.</p>
<p><b>See also </b><a href="qglcontext.html#windowCreated">windowCreated</a>().</p>
<!-- @@@setWindowCreated -->
<!-- $$$swapBuffers[overload1]$$$swapBuffers -->
<h3 class="fn" id="swapBuffers"><a name="swapBuffers"></a><code>[virtual] </code><span class="type">void</span> QGLContext::<span class="name">swapBuffers</span>() const</h3>
<p>Call this to finish a frame of OpenGL rendering, and make sure to call <a href="qglcontext.html#makeCurrent">makeCurrent</a>() again before issuing any further OpenGL commands, for example as part of a new frame.</p>
<!-- @@@swapBuffers -->
<!-- $$$textureCacheLimit[overload1]$$$textureCacheLimit -->
<h3 class="fn" id="textureCacheLimit"><a name="textureCacheLimit"></a><code>[static] </code><span class="type">int</span> QGLContext::<span class="name">textureCacheLimit</span>()</h3>
<p>Returns the current texture cache limit in kilobytes.</p>
<p><b>See also </b><a href="qglcontext.html#setTextureCacheLimit">setTextureCacheLimit</a>().</p>
<!-- @@@textureCacheLimit -->
<!-- $$$windowCreated[overload1]$$$windowCreated -->
<h3 class="fn" id="windowCreated"><a name="windowCreated"></a><code>[protected] </code><span class="type">bool</span> QGLContext::<span class="name">windowCreated</span>() const</h3>
<p>Returns <code>true</code> if a window has been created for this context; otherwise returns <code>false</code>.</p>
<p><b>See also </b><a href="qglcontext.html#setWindowCreated">setWindowCreated</a>().</p>
<!-- @@@windowCreated -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2020 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
